Functions: 
  Move ---> Move head and tail in current direction
      use a queue for the snake
      store locations of the head & body & tail
      after determining direction and next loc of head, store that in the queue and increment head pointer
      set current tail LED off and increment tail pointer
      if at end of queue, wrap around to beginning of memory space (la s0 and addi s0, 1)
  Check direction ---> Read keypad/last dir, use for move
  Check frog --> Check if next LED is a frog, if yes do Grow instead of Move
    Grow ---> Move head, add segment to body, tail remains in place, increments score
                if score == # frogs generated, game is over, exit
  Check wall ---> Check if next LED is a wall, if yes go to Change direction
  Change direction ---> Changes direction if needed (hit wall)
  Check snake ---> Check if next LED is part of the snake, if yes go to Exit
  Exit ---> Ends the game, display time played and score
  *done* Build board ---> read the board string and set the appropriate LEDs to red
                    If char = *, turn LED on
                    If char = 0x00, end loop
                    If char = anything else, ignore
  *done* Populate frogs 
  
  Get LED 
  Set LED
  
  
Initialize game:
  Read board string *done*
  Build board (Red LEDS) *done*
  Create snake
  - row 31, cols 4-10
  - set head var & address
  - set body array & addresses
  - set tail var and address
  Populate frogs (Can't be on walls or snake start position)  *done*
  
  
Loop for rest of game:
  Time loop
    time syscall
    compare to last time
    if <200ms, loop again
    else, continue program
  Check direction/keystroke
  Check snake
    Exit
  Check wall
    Change direction
  Check frog
    Move/Grow
  Increment time counter


Variables:
  Snake head pointer
  Snake tail pointer
  Snake body (don't need a pointer or anything)
  # frogs generated (s1)
  Time
    time began
    last time moved (possible temp)
    (temp) curr time
  Score (# frogs eaten)
  LED address(es)
  stack?
